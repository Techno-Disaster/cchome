<!doctype html><html lang=en class=dark><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.81.0"><link rel=apple-touch-icon sizes=180x180 href=https://ccextractor.netlify.app/favicons/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://ccextractor.netlify.app/favicons/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://ccextractor.netlify.app/favicons/favicon-16x16.png><link rel=manifest href=https://ccextractor.netlify.app/favicons/site.webmanifest><link rel=mask-icon href=https://ccextractor.netlify.app/favicons/safari-pinned-tab.svg color=#004750><link rel="shortcut icon" href=https://ccextractor.netlify.app/favicons/favicon.ico><meta name=msapplication-config content="https://ccextractor.netlify.app/favicons/browserconfig.xml"><title>Python extension module for CCExtractor | CCExtractor</title><meta property="og:title" content="Python extension module for CCExtractor"><meta property="og:description" content="This is the main documentation of Python extension module for CCExtractor:
CCExtractor Library Refactoring the codebase into a library Earlier version of CCExtractor was compiled as a binary and could not be used as a library. The entire codebase was executed via a single main function defined in ccextractor.c and this architecture was not suitable for extending ccextractor source code to a library. Hence, many modifications were made to ccextractor.c so that conversion to a library could be done."><meta property="og:type" content="article"><meta property="og:url" content="https://ccextractor.netlify.app/public/gsoc/python_extension_module_technical_documentation_gsoc_17/"><meta property="article:section" content="public"><meta property="article:modified_time" content="2021-03-17T11:15:27+05:30"><meta itemprop=name content="Python extension module for CCExtractor"><meta itemprop=description content="This is the main documentation of Python extension module for CCExtractor:
CCExtractor Library Refactoring the codebase into a library Earlier version of CCExtractor was compiled as a binary and could not be used as a library. The entire codebase was executed via a single main function defined in ccextractor.c and this architecture was not suitable for extending ccextractor source code to a library. Hence, many modifications were made to ccextractor.c so that conversion to a library could be done."><meta itemprop=dateModified content="2021-03-17T11:15:27+05:30"><meta itemprop=wordCount content="5464"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Python extension module for CCExtractor"><meta name=twitter:description content="This is the main documentation of Python extension module for CCExtractor:
CCExtractor Library Refactoring the codebase into a library Earlier version of CCExtractor was compiled as a binary and could not be used as a library. The entire codebase was executed via a single main function defined in ccextractor.c and this architecture was not suitable for extending ccextractor source code to a library. Hence, many modifications were made to ccextractor.c so that conversion to a library could be done."><link rel=stylesheet href=https://ccextractor.netlify.app/css/styles.691e1175b9b265f22727d90637a62963a8bc963d776a8fbeed95a74e87f589a5943592899c51a62f56754edc55745c52af817c925bdbb1947cec7af4897c6e73.css integrity="sha512-aR4RdbmyZfInJ9kGN6YpY6i8lj13ao++7ZWnTof1iaWUNZKJnFGmL1Z1TtxVdFxSr4F8klvbsZR87Hr0iXxucw=="><meta name=description content="This is the main documentation of Python extension module for CCExtractor:
CCExtractor Library Refactoring the codebase into a library Earlier version of CCExtractor was compiled as a binary and could not be used as a library. The entire codebase was executed via a single main function defined in ccextractor.c and this architecture was not suitable for extending ccextractor source code to a library. Hence, many modifications were made to ccextractor.c so that conversion to a library could be done."></head><body class=page-page data-code=7 data-lines=false><header class=nav_header><nav class="wrap nav menu"><a href=https://ccextractor.netlify.app/ class=nav_brand><picture data-lit=https://ccextractor.netlify.app/images/ccx.svg data-dark=https://ccextractor.netlify.app/images/ccx.svg><source srcset=https://ccextractor.netlify.app/images/ccx.svg media="(prefers-color-scheme: dark)"><img srcset=https://ccextractor.netlify.app/images/ccx.svg alt="CCExtractor Logo"></picture>
<label class="nav_toggle toggle" title="Site Menu" role=button><svg class="icon icon_harmburger"><use xlink:href="#harmburger"/></svg></label></a><ul class=nav_body><li class=nav-item></li><li class=nav-item><a class=nav-link href=https://ccextractor.netlify.app/docs/><span>Docs</span></a></li><li class="nav-item nav_repo"><a class=nav-link href=https://github.com/CCExtractor/ target=_blank><picture data-lit=https://ccextractor.netlify.app/images/GitHubMarkLight.svg data-dark=https://ccextractor.netlify.app/images/GitHubMarkDark.svg><source srcset=https://ccextractor.netlify.app/images/GitHubMarkDark.svg media="(prefers-color-scheme: dark)"><img srcset=https://ccextractor.netlify.app/images/GitHubMarkLight.svg alt="GitHub Repo"></picture></a></li><li class=nav-item><div class=color_mode><label for=mode><picture data-lit=https://ccextractor.netlify.app/icons/sun.svg data-dark=https://ccextractor.netlify.app/icons/moon.svg><source srcset=https://ccextractor.netlify.app/icons/moon.svg media="(prefers-color-scheme: dark)"><img srcset=https://ccextractor.netlify.app/icons/sun.svg alt="Light/Dark Mode Icon" class=color_icon></picture></label>
<input type=checkbox class=color_choice id=mode title="Toggle Dark Mode"></div></li></ul></nav></header><div class="main wrap pt-4"><div class=content><h1>Python extension module for CCExtractor</h1><p>This is the main documentation of Python extension module for
CCExtractor:</p><h5 id=ccextractor-library>CCExtractor Library</h5><h4 id=refactoring-the-codebase-into-a-library>Refactoring the codebase into a library</h4><p>Earlier version of CCExtractor was compiled as a binary and could not be
used as a library. The entire codebase was executed via a single main
function defined in ccextractor.c and this architecture was not suitable
for extending ccextractor source code to a library. Hence, many
modifications were made to ccextractor.c so that conversion to a library
could be done. Major modifications were:</p><ul><li>Segmenting the larger functions into smaller functions so that they could be called from one main function. Earlier the entire processing was carried out from one main function itself. This was not a good idea considering the possibility for library. This would allow the user to set the parameters to be passed to CCExtractor from Python with one parameter at a time and not the entire list of all parameters together.</li><li>The refactoring of the code base and architectural judgements as to how the code should be segmented so that the entire working remains the same and also the library structure could be established.</li></ul><p>Apart from these changes, the header file ccextractor.h was also
included into the codebase to define many global variables as well as
the function declarations of definitions made in ccextractor.c. The
major changes could be seen at this <a href=https://github.com/CCExtractor/ccextractor/pull/744>PR (merged)</a>.
However, following the next stages of development after the changes made
in the above mentioned PR, the final structure could be found at
<a href=https://github.com/CCExtractor/ccextractor/blob/master/src/ccextractor.c>ccextractor.c</a>
and
<a href=https://github.com/CCExtractor/ccextractor/blob/master/src/ccextractor.h>ccextractor.h</a>.</p><h4 id=definitions-made-in-ccextractorh>Definitions made in ccextractor.h</h4><ul><li>In ccextractor.h, the major changes included declaring global variables which would be accessible throughout the codebase for calling the respective callbacks (discussed later in the documentation) from C to Python for processing the caption frames in Python as they are extracted in CCExtractor. The global variable was also used to keep a track of the start time and end time of caption frames so that the CE-608 grids belonging to the same frame could be clubbed together. The global variable <a href=https://github.com/CCExtractor/ccextractor/blob/master/src/ccextractor.h#L46>array</a> has been defined and the <a href=https://github.com/CCExtractor/ccextractor/blob/master/src/ccextractor.h#L35>respective structure</a> definition has also been done in ccextractor.h.</li><li>The global variable array is an instance of this <a href=https://github.com/CCExtractor/ccextractor/blob/master/src/ccextractor.h#L35>structure</a>. The elements of the structure are PyObject* reporter, int sub_count and struct python_subs_modified* subs. The <a href=https://github.com/CCExtractor/ccextractor/blob/master/src/ccextractor.h#L30>subs</a> has been defined with start_time and end_time as its elements. More detailed description about why start_time and end_time have been used is given in the section describing about extractors. The main motivation for defining a global variable to catch hold of start time and end time of the caption frames as they are processed in CCExtractor is to identify the text, font and color grids (for CE-608 captions) that belong to the same caption frame.</li><li>The major point to note is that the compilation of Python extension module includes <a href=https://github.com/CCExtractor/ccextractor/blob/master/api/build_api#L19>setting a macro</a> PYTHONAPI which acts as an indication that the compilation is made for Python extension module and this helps in declaring as well as defining the functions which are only needed for Python extension module. As defined <a href=https://github.com/CCExtractor/ccextractor/blob/master/src/ccextractor.h#L36>here</a>, the PYTHONAPI macro is used to define the functions/variables which are needed only by the extension module.</li><li>Another major advantage of defining the macro PYTHONAPI is that the definitions made for Python extension module only need python-dev package as a prerequisite for compilation. However, if the user wants to compile only CCExtractor and not the Python extension module, then the code should not have python-dev package as a dependency. This has been attained by using macro PYTHONAPI and C pre-processors.</li></ul><h5 id=ccextractor-python-extension-module>CCExtractor Python Extension Module</h5><h4 id=extension-module-dependencies>Extension module dependencies</h4><h3 id=1-swig>1. SWIG</h3><ul><li>For generation of the wrappers of the C code base, which would then be used to compile the extension module, I have used <a href=http://www.swig.org/>SWIG</a> (swig-3.0.12). The entire compilation has been included in a build script (discussed later) and the user need not have prior knowledge of SWIG to get started.</li><li>For compiling the Python extension module, the second dependency in addition to the dependencies of CCExtractor is SWIG. The user can follow these <a href=http://www.swig.org/download.html>installation steps</a> for getting SWIG installed.</li><li>For generating the wrappers of the C/C++ code in a user required language, the user needs to have a basic understanding of the <a href=http://www.swig.org/Doc3.0/Introduction.html#Introduction_nn5>interface file</a> which is used by SWIG. However, in case of generating the extension module for CCExtractor, the interface file has been written and is available <a href=https://github.com/CCExtractor/ccextractor/blob/master/api/ccextractor.i>here</a>. SWIG uses this interface file to generate the wrappers for CCExtractor which are then compiled to form the extension module.</li></ul><h3 id=2-python-dev-package>2. Python-dev package</h3><h4 id=overall-architecture>Overall architecture</h4><ul><li>The entire Python Extension module related work is done in the <a href=https://github.com/CCExtractor/ccextractor/tree/master/api>api/</a> directory with modifications to the CCExtractor codebase to integrate the divergent path, CCExtractor would take if the processing is done via Python module.</li></ul><h4 id=generating-the-python-extension-module>Generating the Python extension module</h4><ul><li>For this project, I have mainly used two build scripts, viz., <a href=https://github.com/CCExtractor/ccextractor/blob/master/api/build_api>build_api</a> and <a href=https://github.com/CCExtractor/ccextractor/blob/master/api/build_library>build_library</a> which are both present in the api/ directory. For generating the Python bindings, user need to just run the build_library script as ./build_library. This would internally generate the SWIG wrappers from the SWIG interface file (ccextractor.i) present in the same directory. The user should note that if the user has not installed SWIG, the the compilation would stop at this step itself. Once the wrappers are generated, then the build_library script would execute the build_api script which would compile the entire code base of CCExtractor along with the wrappers generated by SWIG. In addition to this, build_api would also compile the extractors and wrappers defined in the extractors/ and wrappers/ directories respectively. Once the compilation is successful, then build_library would generate a shared library called _ccextractor.so from the entire code which would be shared object for the module.</li><li>In addition to generating the wrapper codes generated by SWIG, it also outputs the ccextractor.py which would be later used as Python extension module for accessing CCExtractor functionality via Python.</li><li>As mentioned in earlier section, the build_api compiles the entire code base with an option -DPYTHONAPI which is used by GCC to define a macro PYTHONAPI. This macro then acts as a signal telling that the extension module is being generated and the bindings dependency need a check as well as the bindings dependent functions need to be defined.</li></ul><h4 id=workflow-of-python-extension-module>Workflow of Python extension module</h4><p>The following section encompasses on the detailed description of the
entire workflow of Python extension modules and the importance of each
function in the codeflow. An example usage has been done in
<a href=https://github.com/CCExtractor/ccextractor/blob/master/api/api_testing.py>api_testing.py</a>.</p><h3 id=api_init_options>api_init_options</h3><p>Function declaration- <em><em>struct ccx_s_options</em> api_init_options()</em>*</p><ul><li>This function returns an initialized instance of struct ccx_s_options which is modified in CCExtractor according to the values of the parameters provided by the user while executing CCExtractor.</li></ul><h3 id=check_configuration_file>check_configuration_file</h3><p>Function declaration- <strong>void check_configuration_file(struct ccx_s_options api_options)</strong> This function is used to check the
configuration file and it takes the struct ccx_s_options instance as
returned by api_init_options().</p><h3 id=api_add_param>api_add_param</h3><p>Function declaration- <em><em>void api_add_param(struct ccx_s_options</em> api_options,char</em> arg)**</p><ul><li>The api_add_param function is used to add user passed parameters to the struct ccx_s_options instance which would be used to compile the parameters and make the necessary modifications in the working of CCExtractor.</li><li>This function takes the instance of struct ccx_s_options passed to check_configuration_file function and also, the string denoting the parameter passed by the user.</li><li>The parameters are added to the <a href=https://github.com/CCExtractor/ccextractor/blob/master/src/lib_ccx/ccx_common_option.h#L198>python_params</a> element of struct ccx_s_options and the count of the parameters is kept in <a href=https://github.com/CCExtractor/ccextractor/blob/master/src/lib_ccx/ccx_common_option.h#L199>python_param_count</a>.</li></ul><h3 id=my_pythonapi>my_pythonapi</h3><p>Function declaration- <strong>(depends on whether the compilation is done as CCExtractor binary or as extension modules)</strong></p><ul><li>The my_pythonapi is defined on the basis of how the compilation has been done by the user. If the user wants to use CCExtractor binary rather than the Python extension module, then this function is defined as #define my_pythonapi(args, func) set_pythonapi(args) with the set_pythonapi being defined in <a href=https://github.com/CCExtractor/ccextractor/blob/master/api/wrappers/wrapper.c#L4>wrapper.c</a>.</li><li>However, if the user wants to build the extension module, then the definition of my_pythonapi is done as #define my_pythonapi(args, func) set_pythonapi_via_python(args, func) with the set_pythonapi_via_python function being defined in <a href=https://github.com/CCExtractor/ccextractor/blob/master/api/wrappers/wrapper.c#L8>wrapper.c</a>.</li><li>Thus, it can been observed that my_pythonapi takes two arguments when the compilation is done as extension module. In both the case, the first argument is struct ccx_s_options instance as used by api_add_param. But in case of compiling the extension module, the my_pythonapi function takes a second parameter which is the python callback function that CCExtractor would call when passing values from C to Python (a detailed discussion about this has been done later).</li><li>This function is not a mandatory function to call when using the CCExtractor binary.</li></ul><h3 id=compile_params>compile_params</h3><p>Function declaration- *<em>int compile_params(struct ccx_s_options <em>api_options,int argc)</em></em></p><ul><li>The compile_params function mainly compiles all the parameters supplied by the user and modifies the elements of the api_options on the basis of the parameters supplied by the user.</li><li>In this function, we add a dummy parameter ./ccextractor so that the parse_params function which is called from compile_params function properly compiles all the parameter except the first parameter as done in <a href=https://github.com/CCExtractor/ccextractor/blob/master/src/lib_ccx/params.c#L1101>here</a>.</li><li>This function then returns the return value as obtained by the <a href=https://github.com/CCExtractor/ccextractor/blob/master/src/lib_ccx/params.c#L1098>parse_params function</a>.</li></ul><h3 id=call_from_python_api>call_from_python_api</h3><p>Function declaration- *<em>void call_from_python_api(struct ccx_s_options <em>api_options)</em></em></p><ul><li>The call_from_python_api function checks if the parameter -pythonapi was provided by the user. If the parameter was passed by the user then the global varable signal_python_api is set to 1 showing that the execution is done via Python modules; otherwise the value of signal_python_api is 0.</li><li>In case of clarifications, the user does not explicitly need to pass the parameter -pythonapi. It is passed by the my_pythonapi function and thus used by call_from_python_api to set the signal_python_api to 1.</li></ul><h3 id=api_start>api_start</h3><p>Function declaration- <strong>int api_start(struct ccx_s_options api_options)</strong></p><ul><li>This is the most important function of entire processing done by CCExtractor. After the entire compiling of parameters have been completed, then comes the stage when the actual processing is done.</li><li>The api_start is the function which is majorly responsible for extracting the caption frames and passing them back to Python for processing.</li></ul><p>The user should note that the codeflow discussed above till this point
is generic to both CCExtractor binary as well as CCExtractor's Python
extension module. From this point onwards, the codeflow that has been
described is mainly how the Python extension module accepts the caption
frames via callback function and then processings done on the caption
frames to generate the output subtitle file (.srt) via Python.</p><ul><li>The api_start function in case of CE-608 captions calls a function general_loop for processing of the sample(video) that needs to be processed which in turn makes a call to encode_sub which encodes the subtitle buffer obtained from the sample.</li><li>In <a href=https://github.com/CCExtractor/ccextractor/blob/master/src/lib_ccx/ccx_encoders_common.c#L1070>encode_sub function</a>, the sub_type is checked to be CE-608. If the sub_type is 608, then another check is made to check the value of <a href=https://github.com/CCExtractor/ccextractor/blob/master/src/lib_ccx/ccx_encoders_common.c#L1133>signal_python_api</a>. If the signal_python_api is set to 1, then a call to <a href=https://github.com/CCExtractor/ccextractor/blob/master/src/lib_ccx/ccx_encoders_common.c#L1133>pass_cc_buffer_to_python</a> is made. Otherwise, the processing continues as if the call for processing was made from CCExtractor binary.</li></ul><p>From the pass_cc_buffer_to_python function, the call is made to the
<a href=https://github.com/CCExtractor/ccextractor/blob/master/src/lib_ccx/ccx_encoders_python.c#L32>extractor function</a>,
then the extractor function in turns <a href=https://github.com/CCExtractor/ccextractor/blob/master/api/extractors/extractor.c#L88>calls the callback function</a>
provided earlier via my_pythonapi function. The arguments given to the
callback function are the ones corresponding to the information content
of the caption frame which has been processed by CCExtractor. This
information is accessed via the Python SRT generator scripts which would
process the caption frames and write the processed information in the
output subtitle files. The following sections would be sequential
in-detail descriptions about how each process functions:</p><h4 id=python-encoder-for-ccextractor>Python Encoder for CCExtractor</h4><ul><li>Following the architecture of CCExtractor’s codebase, a new file named ccx_encoders_python.c was added. The main reason of adding this file was to define the functions which would be called when the extraction process or CCExtractor extraction functionality is being performed via Python extension module. At this moment, since the extension module extends support only for CE-608 samples, only pass_cc_buffer_to_python function has been defined. Later on, when the binding’s support is extended to support other formats then in that case other functions like pass_cc_bitmap_to_python and others would be included in this file following the architecture of other encoders.</li></ul><h3 id=pass_cc_buffer_to_python>pass_cc_buffer_to_python</h3><p>Function declaration- **int pass_cc_buffer_to_python(struct eia608_screen <em>data, struct encoder_ctx <em>context)</em></em></p><ul><li>This is the function where the actual work of passing the extracted caption buffer to Python extension modules for processing the caption frames is done.</li><li>The pass_cc_buffer_to_python function is called when the sample from which the caption frames are to be extracted is a CE-608 sample and the call for extraction is made from Python extension module.</li><li>In this function, whenever a caption frame element is extracted, be it the srt_counter, caption timing information or any information related to the text, font or color grid of the CE-608 captions, then that information is passed to <a href=https://github.com/CCExtractor/ccextractor/blob/master/src/lib_ccx/ccx_encoders_python.c#L32>extractor function</a> defined in extractors/ directory. A detailed description about how exactly the extractors function would be included in the next section.</li></ul><h4 id=extractors-for-bindings>Extractors for bindings</h4><ul><li>As documented in the previous section, when the extraction of CE-608 caption frames in done via Python, then the call is made to pass_cc_buffer_to_python function defined in ccx_encoders_python.c. In this function, after extracting lines in a caption frame (lines may belong to any of the text, font or color grid for CE-608), those lines are passed to <a href=https://github.com/CCExtractor/ccextractor/blob/master/api/extractors/extractor.c#L3>python_extract_g608_grid</a> function defined in extractors.c.</li></ul><h3 id=python_extract_g608_grid>python_extract_g608_grid</h3><p>Function declaration- <em><em>void python_extract_g608_grid(unsigned h1, unsigned m1, unsigned s1, unsigned ms1, unsigned h2, unsigned m2, unsigned s2, unsigned ms2, char</em> buffer, int identifier, int srt_counter, int encoding)</em>*</p><ul><li>The main aim of using python_extract_g608_grid function is to able to identify the lines belonging to a particular frame and then passing these lines to the Python callback function with added identifiers for identification as to which CE-608 grid those lines belong to in a particular caption frame. More documentation about the identifiers and the nomenclature used for the bindings has been documented in the ‘Support for only CE-608 captions’ section and the user is advised to read that section to get a better understanding of the nomenclature.</li><li>The arguments passed to python_extract_g608_grid include encoding which is the encoding that CCExtractor would have used to write the output subtitle file. Thus, the encoding is passed from CCExtractor to Python via the callback function so that the output subtitle file generated by Python would have the same encoding as the output generated by CCExtractor would have had.</li><li>Out of all the arguments that are passed to the python_extract_g608_grid function, the one interesting argument is the <a href=https://github.com/CCExtractor/ccextractor/blob/master/api/extractors/extractor.c#L4>identifier</a> argument which has different values depending on the type of caption frame line it is called with. For example, if the line passed to python_extract_g608_grid function is a line belonging to its color grid, then the value of the identifier would be 2. Similarly, we have:<ul><li>identifier = 0 -> adding start and end time</li><li>identifier = 1 -> subtitle</li><li>identifier = 2 -> color</li><li>identifier = 3 -> font</li></ul></li><li>This is how the python_extract_g608_grid function is able to generate the entire caption frame for a CE-608 sample along with timings.</li></ul><h4 id=callback-function-architecture>Callback Function architecture</h4><ul><li>When using the extension module, when a particular C function is called from Python, the control is transferred to C and returned to Python only after the execution of the function. However, according to the adopted architecture, a single function would process the entire sample and extract all the caption frames until the control is passed back to Python for processing the captions in Python. Thereupon, for further processing in Python the user would have had to wait until the end of the extraction of all the caption frames from the sample. This would violate the basic ideology that the module should be able to process the caption frames in Python as they are extracted in CCExtractor rather than waiting till the end of extraction from the entire sample.</li><li>As a result of this, the callback function architecture was adopted. The main advantage of this architecture is that the moment a line from the caption frame is extracted the line is passed via a callback function to Python and the processing of the extracted line could be done in Python.</li><li>In the present architecture, the user has a flexibility to tell CCExtractor which Python function would act as a callback function and a mechanism has been designed to convey this function to CCExtractor. This has been done with the use of my_pythonapi function as discussed in the previous sections.</li><li>NOTE: In the api_testing.py, I have defined the callback function to be named <a href=https://github.com/CCExtractor/ccextractor/blob/master/api/api_testing.py#L25>callback</a>. However, the user has complete freedom to define any name for the callback function. The user needs to note that the callback function would be getting nothing but a line from the caption frame that is extracted by CCExtractor. Further processing of the extracted line is the responsibility of the user.</li><li>After defining the callback function, the user needs to make sure that this function is passed via Python to CCExtractor so that it can be used for callback. For doing so, the user needs to set the second argument of the function my_pythonapi as the callback function. This has been done in the api_testing.py script and the user can refer to it for <a href=https://github.com/CCExtractor/ccextractor/blob/master/api/api_testing.py#L16>example</a>.</li><li>A detailed description about why a single line of the caption frame is passed via the callback function and not the entire frame is described in detail in later sections.</li><li>Also, when the user passes the callback function via Python to CCExtractor so the <a href=https://github.com/CCExtractor/ccextractor/blob/master/api/wrappers/wrapper.c#L10>my_pythonapi function</a> saves a pointer to this function as an element to a global structure, array, defined and declared in ccextractor.h. The element <a href=https://github.com/CCExtractor/ccextractor/blob/master/src/ccextractor.h#L37>reporter</a> holds the callback function passed by user via Python.</li><li>Whenever the user wants to pass a line to the callback function then the user needs to call the function <a href=https://github.com/CCExtractor/ccextractor/blob/master/src/ccextractor.c#L553>run</a> which has been defined in ccextractor.c.</li></ul><h3 id=run>run</h3><p>Function declaration- <strong>void run(PyObject * reporter, char * line, int encoding)</strong></p><ul><li>The run function takes two arguments and their description is as follows:<ul><li>The first argument is the callback function which the user passes via Python. According to present architecture, this callback function is contained by the element reporter contained in the global structure named array. So the first argument is array.reporter.</li><li>The second argument to the run function is the line which needs to be passed to Python.</li></ul></li></ul><p>This is how the callback mechanism works for passing the lines from C to
Python in real time.</p><h4 id=processing-output-in-python>Processing output in Python</h4><ul><li>As described in the previous sections, the extension modules just return a single line from the caption frames. The processing of the caption frames to generate the output subtitle file is done in Python.</li><li>A script to generate an output subtitle file from the extracted captions frames in Python has been written. The api_testing.py has a function named callback which acts as a callback function returning the extracted caption lines in Python. These lines then are passed to <a href=https://github.com/CCExtractor/ccextractor/blob/master/api/api_support.py#L7>generated_output_srt</a> in api_support.py described in the api/ directory. Thereupon, the function searches if the line has specific identifier which are used to decide how the output would be generated. A detailed section has been included in this documentation regarding the nomenclature used for processing different lines in CE-608 format caption fields (Support for only CE-608 captions section). The main reason for doing so is to avoid any buffering in C to hold the caption lines until the entire caption frames are extracted. This facilitates real time processing of the extracted caption frames.</li><li>For <a href=https://github.com/CCExtractor/ccextractor/blob/master/api/api_support.py#L10>getting the output filename</a> from CCExtractor which would then be used to write the output srt file from Python, whenever the code is run from the extension module the first line that is passed via the callback function is the output filename generated by CCExtractor. This is incorporated by <a href=https://github.com/CCExtractor/ccextractor/blob/master/src/lib_ccx/output.c#L58>calling the callback function from init_write</a> function defined in the src/lib_ccx/output.c file. The line passed to the callback function is of the format filename-<name of the output file to be generated> and this is then used to generate the output file. This line is then captured in the generate_output_srt function defined in the api_support.py.</li><li>However, if the user wants the flexibility of defining the filename in a different manner, then for such outputs, the user must make changes in the generate_output_srt function to set the filename and ignoring the first line that appears in Python via the callback function.</li></ul><h4 id=support-for-only-ce-608-captions>Support for only CE-608 captions</h4><p><strong>For understanding the CE-608 caption format, the user is advised to refer to this <a href=https://github.com/CCExtractor/ccextractor/blob/master/docs/G608.TXT>documentation on CE-608</a>.</strong></p><ul><li>The Python extension module is so far able to extract the captions frames from CE-608 samples. In samples with CE-608, the caption frames that are extracted by CCExtractor are in the form a 15x32 grid which depicts the screen. Thus, the information regarding the font of the captions, the colour they would be having on the screen as well as their alignment on the screen is captured in font,color and text grids respectively.</li><li>Using Python modules each of such grids can be accessed in Python. However, as described in the previous section the callback function gets a single line and not the entire grid from CCExtractor, some processing needs to be done in Python for getting the user required grids per caption frames.</li><li>The functions which would be acting as the processing and buffering functions for grid generations are present in the <a href=https://github.com/CCExtractor/ccextractor/blob/master/api/ccx_to_python_g608.py>ccx_to_python_g608.py</a>. The two major functions are <a href=https://github.com/CCExtractor/ccextractor/blob/master/api/ccx_to_python_g608.py#L15>return_g608_grid</a> and <a href=https://github.com/CCExtractor/ccextractor/blob/master/api/ccx_to_python_g608.py#L1>g608_grid_former</a>. The g608_grid_former is mainly used to form the grid from lines obtained at the callback function.</li><li>The main advantage of the return_g608_grid function is that the user can generate whatever pattern the user desires to process in Python. For accessing various different combinations of the font, color and text grids in CE-608, a <a href=https://github.com/CCExtractor/ccextractor/blob/master/api/ccx_to_python_g608.py#L17>help_string</a> has been defined in the return_g608_grid function in the ccx_to_python_g608.py file which describes on the value of mode to be passed to this function to get proper combination of the grids.</li><li>In the earlier sections it has been stated that the callback function in Python is not passed with the entire caption frame but just one single line from the frame, a particular nomenclature has been devised to make sure that the lines belonging to the same caption frames are identified in the Python interface. The nomenclature is as follows:<ul><li>For every frame, the <a href=https://github.com/CCExtractor/ccextractor/blob/master/api/extractors/extractor.c#L88>first line</a> that is passed to the callback function is the srt_counter which indicates the identifier value of the caption frame that would be extracted next.</li><li>Following the srt_counter, the next line would contain a conjunction of the <a href=https://github.com/CCExtractor/ccextractor/blob/master/api/extractors/extractor.c#L96>start time and end time</a> of the caption frame with respect to the timings when the captions would be visible on the screen. The start_time and end_time would be conjuncted as start_time-<start time>t end_time-<end time>n and the user needs to process this line to get the timings. This processing in case of getting a srt file as an output has been done in the <a href=https://github.com/CCExtractor/ccextractor/blob/master/api/api_support.py#L18>generate_output_srt function</a>.</li><li>After the timings have been sent via the callback function, until the next srt_counter is extracted, the lines containing information about the color, font or text grids of CE-608 samples are passed via the callback function to Python.</li><li>For processing the grids separately, the color grid could be identified by identifying the presence of color[&lt;srt_counter value>]:<color grid line> in the line obtained from the callback function. Similarly, for the font and text grids, the nomenclatures are font[&lt;srt_counter value>]:<font grid line> and text[&lt;srt_counter value>]:<text grid line> respectively. Processing a grid on the basis of such a nomenclature has been done in the g608_grid_former in the ccx_to_python_g608.py file.</li><li>After the entire caption frame has been sent via the callback function to Python for further processing, when the extraction of present caption frames finishes and CCExtractor shifts to a new frame, then a line containing <em><strong>END OF FRAME</strong></em> is passed via the callback function from C to Python. The user needs to catch this line in order to get the signal that from the next line onwards a new caption frame would begin. <a href=https://github.com/CCExtractor/ccextractor/blob/master/api/api_support.py#L28>Similar approach</a> has been implemented in the function generate_output_srt in the api_support.py file.</li></ul></li></ul><p>This is how the entire CE-608 is transmitted to Python and the user
needs to follow the nomenclature in order to get the caption frames in
Python.</p><ul><li>However, if the user thinks to modify the nomenclature in accordance with some other nomenclature that suits their use case, then the user can do so by editing the <a href=https://github.com/CCExtractor/ccextractor/blob/master/api/extractors/extractor.c#L3>python_extract_g608_grid</a> function in the extractor.c file. In this file, the user needs to find the lines where the function run is called with its first parameter being the callback function that is passed from Python and the second parameter being the line which is to be passed to Python.</li></ul><h4 id=wrappers-for-the-extension-module>Wrappers for the extension module</h4><ul><li>In case of using an API, it is highly desired to set the parameters desired by the user not via command line but as call to built-in functions. This gave rise to the necessity of wrapper functions which can be called to set certain parameters for directing the functioning of the bindings.</li><li>The wrappers have been defined in the <a href=https://github.com/CCExtractor/ccextractor/blob/master/api/wrappers/wrapper.c>wrapper.c</a> file in api/wrappers/ directory. The user can use just call the wrappers to set some parameters. More wrappers can be defined according to the architecture followed in wrapper.c.</li><li>The user needs to note that the wrappers can be called anytime in between adding parameters to CCExtractor instance (as done in api_testing.py) and before calling the compile_params function from the CCExtractor module.</li><li>Another thing to note about the wrapper is that, the my_pythonapi wrapper function is a very important wrapper function. It tells CCExtractor that the call has been made using the Python module and thus the functioning of CCExtractor is altered. Hence, if the user intends to use the Python module the user is always advised to call this wrapper function with its first argument to be the object returned by api_init function from CCExtractor module and second argument being the callback function which would be called by the CCExtractor to pass the extracted caption lines back to Python.</li></ul><h4 id=test-script>Test Script</h4><ul><li>Once the Python module are generated then the user can use them by importing ccextractor module in Python.</li><li>For testing the output of the bindings a test script, <a href=https://github.com/CCExtractor/ccextractor/blob/master/api/api_testing.py>api_testing.py</a>. But to mention, the module at this stage only supports generating a subtitle file from the CE-608 standard samples only.</li><li>Another testing feature, that has been added is that the user can use <a href=https://github.com/CCExtractor/ccextractor/blob/master/api/recursive_tester.py>recursive_tester.py</a> to generate the subtitle files for all the samples from a directory. The only parameter needed to run this script is the location of all the samples.</li></ul><h4 id=silent-api>Silent API</h4><ul><li>The Python bindings have been designed in such a way that the API is silent in itself as well as in the form of output generation. Silent in itself means that the API doesn’t write out any output to the STDOUT and the entire output of CCExtractor is silenced when the module is used for extraction of caption frames. This feature has been made possible by passing a parameter -pythonapi internally in api_testing.py using the function my_pythonapi() from the ccextractor module. The -pythonapi internally makes CCExtractor to silence all the outputs that could have been generated otherwise.</li><li>If the user wants to add some print functionality from the CCExtractor, then may be defining the prints using printf C function could be an option. Note that the user cannot use the mprint function to get prints from the extension module from inside the CCExtractor C code part as used in CCExtractor to get the desired STDOUT prints as these are silenced via -pythonapi.</li></ul><h4 id=work-status>Work status</h4><ul><li>The proposal made by me for this project had a major component of multi-threading to let CCExtractor’s Python bindings run the CCExtractor’s extraction process in multi-threads.</li><li>However, the end goal was modified while the GSOC 2017 coding period and after Second Phase Evaluation, the main aim was to create a Python extension module for CCExtractor which could process CE-608 video samples, extract the caption information present in them and pass this information to Python for further processing. The module was expected to be silent and the output generation from the caption information present in the video sample has to be done via Python.</li><li>The present status of the extension module is that the module can extract caption information from CE-608 standard video samples and pass the caption information to Python. Further work has also been done to process this caption information to generate an output subtitle(srt) file (the user is advised to check completion of comparing_text_font_grids function sub-section under the future work section).</li></ul><h4 id=future-work>Future Work</h4><h3 id=identifying-the-input-format-and-raising-errors-if-unsupported>Identifying the input format and raising errors if unsupported</h3><ul><li>CCExtractor does not process any non-video files. Similarly, the processing of non-video files is not supported by extension module. However, since the API has been designed to be silent, the module doesn’t output any error log stating that the input file is a non-video file and it cannot be processed.</li><li>This is a much desired feature and the present version of CCExtractor extension module lacks this feature. I would be working on this feature post GSOC 2017 but if any user finds that this feature has not been added until they start contribution to CCExtractor’s extension module, then their work on this feature would be highly appreciated.</li><li>For adding this feature to extension module, the extension module must be extended to process the return value from CCExtractor as done in the <a href=https://github.com/CCExtractor/ccextractor/blob/master/src/ccextractor.c#L71>api_start function</a>. When the sample (non-video) is processed via CCExtractor’s binary, then the processing is stopped by raising an ‘Invalid option to CCExtractor Library’ error. However, since the extension module has been designed to be silent, this error message is suppressed. Hence, the user should extend the test scripts to process the return value of api_start function in python extension module according to the constants defined in <a href=https://github.com/CCExtractor/ccextractor/blob/master/src/lib_ccx/ccx_common_common.h>ccx_common_common.h</a>.</li></ul><h3 id=callback-class-mechanism>Callback class mechanism</h3><ul><li>The present architecture uses a callback mechanism to pass the extracted caption lines from the caption frames of CE-608 captions to Python for further processing. In the callback mechanism, a callback function is supplied to CCExtractor in C via the my_pythonapi function which stores the callback function as a PyObject* in the global variable array. However, according to Python documentation on C-API, everything in Python is a PyObject; be it a function, a tuple or a class.</li><li>So, the ideology is to replace the present callback function by a class which can have many methods that the user can use for different use cases.</li><li>An example of such an implementation has been done <a href=https://github.com/Diptanshu8/ccextractor/blob/callback_class/api/api_testing.py#L27>here</a>. The user needs to note that for accessing the Python class in C, some modifications need to be done to the run function defined in ccextractor.c and a sample example for calling a class method named ‘callback’ could be found <a href=https://github.com/Diptanshu8/ccextractor/blob/callback_class/src/ccextractor.c#L553>here</a>.</li><li>Also, an important point to be noted in this case is that the user needs to pass the callback function’s name to run function in C so that the corresponding callback method of the class passed via my_pythonapi could be called via C. As an example, the callback method’s name has been provided <a href=https://github.com/Diptanshu8/ccextractor/blob/callback_class/src/ccextractor.c#L562>here</a>.</li><li>For understanding the exact implementation of this approach, I would recommend the user to understand C-API for Python as the documentation is quite extensive to every use case.</li></ul><h3 id=completion-of-comparing_text_font_grids-function>Completion of comparing_text_font_grids function</h3><ul><li>The Python extension module for CCExtractor is able to pass lines of the caption frames for different grids of CE-608 captions. However, for generating the subtitle file from the caption grids, the text grid needs to be modified according to the color grid as well as font grid. In CCExtractor, this job is done at the function, <a href=https://github.com/Diptanshu8/ccextractor/blob/callback_class/src/lib_ccx/ccx_encoders_helpers.c#L234>get_decoder_line_encoded</a>.</li><li>For generation of subtitle files (.srt files) from Python, an equivalent version of get_decoder_line_encoded has been implemented in Python and has been defined as <a href=https://github.com/CCExtractor/ccextractor/blob/master/api/python_srt_generator.py#L56>comparing_text_font_grids</a> in python_srt_generator.py</li><li>However, as the user can note that this function is not a complete implementation of get_decoder_line_encoded function, completion of this function’s definition is a matter of future work.</li></ul><h3 id=adding-more-wrapper-functions>Adding more wrapper functions</h3><ul><li>As described in the ‘Wrappers for the extension module’ section, more wrapper functions are needed to be declared in the <a href=https://github.com/CCExtractor/ccextractor/blob/master/api/wrappers/wrapper.c>wrapper.c</a> file. For example, few wrappers have been defined. More wrapper functions can be defined in a similar manner.</li></ul><h3 id=extending-the-module-to-support-other-caption-formats>Extending the module to support other caption formats</h3><ul><li>In this version, CCExtractor’s extension module supports processing of video samples having CE-608 standard captions in them and writing these captions to output subtitle (.srt) files.</li><li>However, CCExtractor in itself has support for other caption standards like DVB, 708 etc. So, extension of module to extract of caption information from samples containing the caption information in these formats is a future task.</li><li>The user should note that the information passed from CE-608 to Python is in raw form as lines which are then used to form the 608 grids. Similarly, the extension to other formats must consider passing the raw information of caption in respective format and then processing the information extracted by CCExtractor in Python.</li><li>While extending, the architecture to be followed for ccx_encoders_python should be consistent to other encoders in the codebase to maintain uniformity. Thus for DVB samples, a function name pass_cc_bitmap_to_python and for 708 samples pass_cc_subtitle_to_python need to be declared in ccx_encoders_python.c.</li></ul></div></div><footer class="pt-2 pb-2"><div class=wrap><p>&copy; <span class=year>2021</span> <a href target=_blank rel=noopener>CCExtractor</a></p></div></footer><svg width="0" height="0" class="hidden"><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 492.004 492.004" id="next"><path d="M484.14 226.886 306.46 49.202c-5.072-5.072-11.832-7.856-19.04-7.856-7.216.0-13.972 2.788-19.044 7.856l-16.132 16.136c-5.068 5.064-7.86 11.828-7.86 19.04.0 7.208 2.792 14.2 7.86 19.264L355.9 207.526H26.58C11.732 207.526.0 219.15.0 234.002v22.812c0 14.852 11.732 27.648 26.58 27.648h330.496L252.248 388.926c-5.068 5.072-7.86 11.652-7.86 18.864.0 7.204 2.792 13.88 7.86 18.948l16.132 16.084c5.072 5.072 11.828 7.836 19.044 7.836 7.208.0 13.968-2.8 19.04-7.872l177.68-177.68c5.084-5.088 7.88-11.88 7.86-19.1.016-7.244-2.776-14.04-7.864-19.12z"/></symbol><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 511.999 511.999" id="search"><path d="M508.874 478.708 360.142 329.976c28.21-34.827 45.191-79.103 45.191-127.309C405.333 90.917 314.416.0 202.666.0S0 90.917.0 202.667s90.917 202.667 202.667 202.667c48.206.0 92.482-16.982 127.309-45.191l148.732 148.732c4.167 4.165 10.919 4.165 15.086.0l15.081-15.082c4.165-4.166 4.165-10.92-.001-15.085zM202.667 362.667c-88.229.0-160-71.771-160-160s71.771-160 160-160 160 71.771 160 160-71.771 160-160 160z"/></symbol><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 241 179" id="harmburger"><path d="M1 10C1 4.477 5.477.0 11 0h220c5.523.0 10 4.477 10 10s-4.477 10-10 10H11C5.477 20 1 15.523 1 10zm0 80c0-5.523 4.477-10 10-10h220c5.523.0 10 4.477 10 10s-4.477 10-10 10H11c-5.523.0-10-4.477-10-10zm9 69c-5.523.0-10 4.477-10 10s4.477 10 10 10h220c5.523.0 10-4.477 10-10s-4.477-10-10-10H10z"/></symbol><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 401.998 401.998" id="sort"><path d="M73.092 164.452h255.813c4.949.0 9.233-1.807 12.848-5.424 3.613-3.616 5.427-7.898 5.427-12.847s-1.813-9.229-5.427-12.85L213.846 5.424C210.232 1.812 205.951.0 200.999.0s-9.233 1.812-12.85 5.424L60.242 133.331c-3.617 3.617-5.424 7.901-5.424 12.85.0 4.948 1.807 9.231 5.424 12.847 3.621 3.617 7.902 5.424 12.85 5.424zm255.813 73.097H73.092c-4.952.0-9.233 1.808-12.85 5.421-3.617 3.617-5.424 7.898-5.424 12.847s1.807 9.233 5.424 12.848L188.149 396.57c3.621 3.617 7.902 5.428 12.85 5.428s9.233-1.811 12.847-5.428l127.907-127.906c3.613-3.614 5.427-7.898 5.427-12.848.0-4.948-1.813-9.229-5.427-12.847-3.614-3.616-7.899-5.42-12.848-5.42z"/></symbol></svg><svg width="0" height="0" class="hidden"><symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="facebook"><path d="M437 0H75C33.648.0.0 33.648.0 75v362c0 41.352 33.648 75 75 75h151V331h-60v-90h60v-61c0-49.629 40.371-90 90-90h91v90h-91v61h91l-15 90h-76v181h121c41.352.0 75-33.648 75-75V75c0-41.352-33.648-75-75-75zm0 0"/></symbol><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18.001 18.001" id="twitter"><path d="M15.891 4.013c.808-.496 1.343-1.173 1.605-2.034a8.68 8.68.0 01-2.351.861c-.703-.756-1.593-1.14-2.66-1.14-1.043.0-1.924.366-2.643 1.078A3.56 3.56.0 008.766 5.383c0 .309.039.585.117.819-3.076-.105-5.622-1.381-7.628-3.837-.34.601-.51 1.213-.51 1.846.0 1.301.549 2.332 1.645 3.089-.625-.053-1.176-.211-1.645-.47.0.929.273 1.705.82 2.388a3.623 3.623.0 002.115 1.291c-.312.08-.641.118-.979.118-.312.0-.533-.026-.664-.083.23.757.664 1.371 1.291 1.841a3.652 3.652.0 002.152.743C4.148 14.173 2.625 14.69.902 14.69c-.422.0-.721-.006-.902-.038 1.697 1.102 3.586 1.649 5.676 1.649 2.139.0 4.029-.542 5.674-1.626 1.645-1.078 2.859-2.408 3.639-3.974a10.77 10.77.0 001.172-4.892v-.468a7.788 7.788.0 001.84-1.921 8.142 8.142.0 01-2.11.593z"/></symbol><symbol aria-hidden="true" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="mail"><path d="M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V4e2c0 26.5-21.5 48-48 48H48c-26.5.0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5.0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"/></symbol><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="calendar"><path d="M452 40h-24V0h-40v40H124V0H84v40H60C26.916 40 0 66.916.0 1e2v352c0 33.084 26.916 60 60 60h392c33.084.0 60-26.916 60-60V1e2c0-33.084-26.916-60-60-60zm20 412c0 11.028-8.972 20-20 20H60c-11.028.0-20-8.972-20-20V188h432v264zm0-304H40v-48c0-11.028 8.972-20 20-20h24v40h40V80h264v40h40V80h24c11.028.0 20 8.972 20 20v48z"/><path d="M76 230h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zM76 310h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zM76 390h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zm80-80h40v40h-40z"/></symbol><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="github"><path d="M255.968 5.329C114.624 5.329.0 120.401.0 262.353c0 113.536 73.344 209.856 175.104 243.872 12.8 2.368 17.472-5.568 17.472-12.384.0-6.112-.224-22.272-.352-43.712-71.2 15.52-86.24-34.464-86.24-34.464-11.616-29.696-28.416-37.6-28.416-37.6-23.264-15.936 1.728-15.616 1.728-15.616 25.696 1.824 39.2 26.496 39.2 26.496 22.848 39.264 59.936 27.936 74.528 21.344 2.304-16.608 8.928-27.936 16.256-34.368-56.832-6.496-116.608-28.544-116.608-127.008.0-28.064 9.984-51.008 26.368-68.992-2.656-6.496-11.424-32.64 2.496-68 0 0 21.504-6.912 70.4 26.336 20.416-5.696 42.304-8.544 64.096-8.64 21.728.128 43.648 2.944 64.096 8.672 48.864-33.248 70.336-26.336 70.336-26.336 13.952 35.392 5.184 61.504 2.56 68 16.416 17.984 26.304 40.928 26.304 68.992.0 98.72-59.84 120.448-116.864 126.816 9.184 7.936 17.376 23.616 17.376 47.584.0 34.368-.32 62.08-.32 70.496.0 6.88 4.608 14.88 17.6 12.352C438.72 472.145 512 375.857 512 262.353 512 120.401 397.376 5.329 255.968 5.329z"/></symbol><symbol viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" id="rss"><circle cx="3.429" cy="20.571" r="3.429"/><path d="M11.429 24h4.57C15.999 15.179 8.821 8.001.0 8v4.572c6.302.001 11.429 5.126 11.429 11.428z"/><path d="M24 24C24 10.766 13.234.0.0.0v4.571c10.714.0 19.43 8.714 19.43 19.429z"/></symbol><symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="linkedin"><path d="M437 0H75C33.648.0.0 33.648.0 75v362c0 41.352 33.648 75 75 75h362c41.352.0 75-33.648 75-75V75c0-41.352-33.648-75-75-75zM181 406h-60V196h60zm0-240h-60v-60h60zm210 240h-60V286c0-16.54-13.46-30-30-30s-30 13.46-30 30v120h-60V196h60v11.309C286.719 202.422 296.93 196 316 196c40.691.043 75 36.547 75 79.688zm0 0"/></symbol><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 612 612" id="arrow"><path d="M604.501 440.509 325.398 134.956c-5.331-5.357-12.423-7.627-19.386-7.27-6.989-.357-14.056 1.913-19.387 7.27L7.499 440.509c-9.999 10.024-9.999 26.298.0 36.323s26.223 10.024 36.222.0l262.293-287.164L568.28 476.832c9.999 10.024 26.222 10.024 36.221.0 9.999-10.023 9.999-26.298.0-36.323z"/></symbol><symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="carly"><path d="M504.971 239.029 448 182.059V84c0-46.317-37.682-84-84-84h-44c-13.255.0-24 10.745-24 24s10.745 24 24 24h44c19.851.0 36 16.149 36 36v108c0 6.365 2.529 12.47 7.029 16.971L454.059 256l-47.029 47.029A24.002 24.002.0 004e2 320v108c0 19.851-16.149 36-36 36h-44c-13.255.0-24 10.745-24 24s10.745 24 24 24h44c46.318.0 84-37.683 84-84v-98.059l56.971-56.971c9.372-9.372 9.372-24.568.0-33.941zM112 192V84c0-19.851 16.149-36 36-36h44c13.255.0 24-10.745 24-24S205.255.0 192 0h-44c-46.318.0-84 37.683-84 84v98.059l-56.971 56.97c-9.373 9.373-9.373 24.568.0 33.941L64 329.941V428c0 46.317 37.682 84 84 84h44c13.255.0 24-10.745 24-24s-10.745-24-24-24h-44c-19.851.0-36-16.149-36-36V320c0-6.365-2.529-12.47-7.029-16.971L57.941 256l47.029-47.029A24.002 24.002.0 00112 192z"/></symbol><symbol viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" id="copy"><path d="M23 2.75A2.75 2.75.0 0020.25.0H8.75A2.75 2.75.0 006 2.75v13.5A2.75 2.75.0 008.75 19h11.5A2.75 2.75.0 0023 16.25zM18.25 14.5h-7.5a.75.75.0 010-1.5h7.5a.75.75.0 010 1.5zm0-3h-7.5a.75.75.0 010-1.5h7.5a.75.75.0 010 1.5zm0-3h-7.5a.75.75.0 010-1.5h7.5a.75.75.0 010 1.5z"/><path d="M8.75 20.5A4.255 4.255.0 014.5 16.25V2.75c0-.086.02-.166.025-.25H3.75A2.752 2.752.0 001 5.25v16A2.752 2.752.0 003.75 24h12a2.752 2.752.0 002.75-2.75v-.75z"/></symbol><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512.001 512.001" id="closeme"><path d="M284.286 256.002 506.143 34.144c7.811-7.811 7.811-20.475.0-28.285-7.811-7.81-20.475-7.811-28.285.0L256 227.717 34.143 5.859c-7.811-7.811-20.475-7.811-28.285.0-7.81 7.811-7.811 20.475.0 28.285l221.857 221.857L5.858 477.859c-7.811 7.811-7.811 20.475.0 28.285a19.938 19.938.0 0014.143 5.857 19.94 19.94.0 0014.143-5.857L256 284.287l221.857 221.857c3.905 3.905 9.024 5.857 14.143 5.857s10.237-1.952 14.143-5.857c7.811-7.811 7.811-20.475.0-28.285L284.286 256.002z"/></symbol><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="open-menu"><path d="M492 236H20c-11.046.0-20 8.954-20 20s8.954 20 20 20h472c11.046.0 20-8.954 20-20s-8.954-20-20-20zm0-160H20C8.954 76 0 84.954.0 96s8.954 20 20 20h472c11.046.0 20-8.954 20-20s-8.954-20-20-20zm0 320H20c-11.046.0-20 8.954-20 20s8.954 20 20 20h472c11.046.0 20-8.954 20-20s-8.954-20-20-20z"/></symbol><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="instagram"><path d="M12 2.163c3.204.0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.849.0 3.205-.012 3.584-.069 4.849-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07-3.204.0-3.584-.012-4.849-.07-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.849.0-3.204.013-3.583.07-4.849.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.849-.069zM12 0C8.741.0 8.333.014 7.053.072c-4.358.2-6.78 2.618-6.98 6.98-.059 1.281-.073 1.689-.073 4.948s.014 3.668.072 4.948c.2 4.358 2.618 6.78 6.98 6.98C8.333 23.986 8.741 24 12 24s3.668-.014 4.948-.072c4.354-.2 6.782-2.618 6.979-6.98.059-1.28.073-1.689.073-4.948s-.014-3.667-.072-4.947c-.196-4.354-2.617-6.78-6.979-6.98-1.281-.059-1.69-.073-4.949-.073zm0 5.838c-3.403.0-6.162 2.759-6.162 6.162S8.597 18.163 12 18.163s6.162-2.759 6.162-6.163c0-3.403-2.759-6.162-6.162-6.162zM12 16c-2.209.0-4-1.79-4-4 0-2.209 1.791-4 4-4s4 1.791 4 4c0 2.21-1.791 4-4 4zm6.406-11.845c-.796.0-1.441.645-1.441 1.44s.645 1.44 1.441 1.44c.795.0 1.439-.645 1.439-1.44s-.644-1.44-1.439-1.44z"/></symbol><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="youtube"><path d="M19.615 3.184c-3.604-.246-11.631-.245-15.23.0-3.897.266-4.356 2.62-4.385 8.816.029 6.185.484 8.549 4.385 8.816 3.6.245 11.626.246 15.23.0C23.512 20.55 23.971 18.196 24 12c-.029-6.185-.484-8.549-4.385-8.816zM9 16V8l8 3.993L9 16z"/></symbol><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="stackoverflow"><path d="M21 27v-8h3v11H0V19h3v8h18z"/><path d="M17.1.2 15 1.8l7.9 10.6 2.1-1.6L17.1.2zm3.7 14.7L10.6 6.4l1.7-2 10.2 8.5-1.7 2zM7.2 12.3l12 5.6 1.1-2.4-12-5.6-1.1 2.4zm-1.8 6.8 13.56 1.96.17-2.38-13.26-2.55-.47 2.97zM19 25H5v-3h14v3z"/></symbol></svg><script src=https://ccextractor.netlify.app/js/bundle.min.4d4a7343ed068be24d2b2fbcfc484ccde43718d5a823a3ade68e6f9707a7b58fdc3d1b456df6f51e51ae0b2b90448e706f1e74d756f3fe4238bf04d42122d32e.js></script></body></html>